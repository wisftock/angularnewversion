# define las etapas de tu pipeline de CI/CD
stages:
  - dependencies
  - test
  - build
  - deploy
#  - sonarqube_scan
  # - sonarqube-check
  # - sonarqube-vulnerability-report

# define los comandos que se ejecutarán antes de cada tarea
#before_script:
#  - npm i -g @angular/cli

# instala las dependencias
install-dependencies:
  stage: dependencies
  # especifica la imagen de Docker que se utilizará para ejecutar los scripts
  image: node:18
  script:
    - npm i
  # especificar que rama ejecutara este stage
  only:
    - master
  # se utiliza para cachear las dependencias de Node.js, lo que acelera los tiempos de construcción posteriores.
  cache:
    # lista los directorios que deben ser cacheados
    paths:
      - node_modules/
    # se utiliza para definir una clave única para el caché
    key:
      files:
        - package-lock.json


#ejecutan las pruebas unitarias
test:
  stage: test
  image: testim/node-chrome
  script:
    - npm run test -- --browsers=ChromeHeadless --watch=false
  # especificar que rama ejecutara este stage
  only:
    - master
  # se utiliza para cachear las dependencias de Node.js, lo que acelera los tiempos de construcción posteriores.
  cache:
    # lista los directorios que deben ser cacheados, si hay cambios en el .json se ejecuta de nuevo el npm i
    paths:
      - node_modules/
    # se utiliza para definir una clave única para el caché
    key:
      files:
        - package-lock.json

# análisis estático de código: Ejecuta el linting para detectar posibles problemas de código.
#lint:
#  stage: test
#  script:
#    - npm run lint
#  only:
#    - master

# instala las dependencias y compila la aplicación Angular en modo de producción.
build:
  stage: build
  image: node:18
  script:
    - npm i -g @angular/cli
    - ng build
  # archivo o paquete generado durante el proceso de desarrollo de software
  artifacts:
    paths:
      - $CI_PROJECT_DIR/dist/
  # especificar que rama ejecutara este stage
  only:
    - master
  # se utiliza para cachear las dependencias de Node.js, lo que acelera los tiempos de construcción posteriores
  cache:
    # se utiliza para definir una clave única para el caché
    key:
      files:
        - package-lock.json
    # lista los directorios que deben ser cacheados
    paths:
      - node_modules
      - $CI_PROJECT_DIR/dist/
    policy: pull-push

#sonarqube
#sonarqube_scan:
#  stage: sonarqube_scan
#  image: sonarsource/sonar-scanner-cli:latest
#  script:
#    - sonar-scanner -Dsonar.login=$SONAR_TOKEN -Dsonar.host.url=$SONAR_HOST_URL

# sonarqube-check:
#   stage: sonarqube-check
#   image:
#     name: sonarsource/sonar-scanner-cli:5.0
#     entrypoint: [""]
#   variables:
#     SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"  # Defines the location of the analysis task cache
#     GIT_DEPTH: "0"  # Tells git to fetch all the branches of the project, required by the analysis task
#   cache:
#     key: "${CI_JOB_NAME}"
#     paths:
#       - .sonar/cache
#   script:
#     - sonar-scanner
#   allow_failure: true
#   only:
#     - merge_requests
#     - master
#     - main
#     - develop

# sonarqube-vulnerability-report:
#   stage: sonarqube-vulnerability-report
#   script:
#     - 'curl -u "${SONAR_TOKEN}:" "${SONAR_HOST_URL}/api/issues/gitlab_sast_export?projectKey=angular174_new-version_93656571-6aa9-47de-9a18-847e9ff672c3&branch=${CI_COMMIT_BRANCH}&pullRequest=${CI_MERGE_REQUEST_IID}" -o gl-sast-sonar-report.json'
#   allow_failure: true
#   only:
#     - merge_requests
#     - master
#     - main
#     - develop
#   artifacts:
#     expire_in: 1 day
#     reports:
#       sast: gl-sast-sonar-report.json
#   dependencies:
#     - sonarqube-check
